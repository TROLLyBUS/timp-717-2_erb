717-2_erb-1-1.c 

Написать программу, печатающую в stdout фразу "Hello, World!" на отдельной строке. Входные данные -. Выходные - string. 

717-2_erb-1-2.c 

Написать программу, принимающую на вход два числа, разделённые пробелом, и суммирующую их. Ввод чисел производить из stdin, вывод результата - в stdout. Вводимые числа не превосходят по модулю 2147483647(int). Выходные - long int. 

717-2_erb-1-3.c 

Написать программу, принимающую на вход числа x и y, разделённые пробелом, и вычисляющую x в степени y. Ввод чисел производить из stdin, вывод результата - в stdout. Вводимые числа не превосходят по модулю 2147483647(int). Реализовывать возведение в степень через цикл/рекурсию не допускается. Выходные - long int.

717-2_erb-2-1.c

Вариант 4. Разность последовательности. На вход подаётся натуральное число n: n не превышает 2147483647, а также n целых чисел x: x по модулю не превышает 2147483647. Вывести значение разности всех х. Входные данные n(int), x(int). Выходные - long int.

717-2_erb-2-2.c

Вариант 15. Сумма чётных кубов. На вход подаётся натуральное число n: n не превышает 2147483647, а также n целых чисел x: x по модулю не превышает 2147483647. Вывести значение суммы кубов всех x, стоящих на четных местах. Вывести значение разности всех х. Входные данные n(int), x(int). Выходные - long int.

717-2_erb-3-1.c

Односвязные списки:

Необходимо реализовать функции для работы с односвязным списком:
	//инициализация пустого списка
		void init(list* l);
	//удалить все элементы из списка
		void clear(list* l);
	//проверка на пустоту списка
		int isEmpty(list* l)
	//поиск элемента по значению. вернуть NULL если элемент не найден
		node* find(list* l, int value);
	//вставка значения в конец списка, вернуть 0 если успешно
		int push_back(list* l, int value);
	//вставка значения в начало списка, вернуть 0 если успешно
		int push_front(list* l, int value);
	//вставка значения после указанного узла, вернуть 0 если успешно
		int insertAfter(node* n, int value);
	//удалить первый элемент из списка с указанным значением, вернуть 0 если успешно
		int remove(list* l, int value);
	//вывести все значения из списка в прямом порядке, через пробел, после окончания вывода перейти на новую строку
		void print(list* l);


Используя реализованные функции реализовать программу которая:
	1. считать количество элементов n: n - натуральное число, не превышающее 2147483647;
	2. создать пустой список, считать n элементов a: a - целое число, не превышающее по модулю 2147483647, и занести их в список;
	3. вывести содержимое списка используя функцию print;
	4. считать k1 ,k2 ,k3: k1, k2, k3 - целые числа, не превышающее по модулю 2147483647, и вывести ‘1’ если в списке существует элемент с таким значением. ‘0’ если нет. Перейти на новую строку.
	5. считать m: m - целое число, не превышающее по модулю 2147483647, и вставить его в конец списка;
	6. вывести содержимое списка используя функцию print;
	7. считать t: t - целое число, не превышающее по модулю 2147483647, и вставить его в начало списка;
	8. вывести содержимое списка используя функцию print;
	9. считать j: j - натуральное число, не превышающее 2147483647, и x: x - целое число, не превышающее по модулю 2147483647, и вставить значение x после j-ого элемента списка;
	10. вывести содержимое списка используя функцию print;
	11. считать z: z - целое число, не превышающее по модулю 2147483647, и удалить первый элемент хранящий значение z из списка;
	12. вывести содержимое списка используя функцию print;
	13. очистить список.

Входные и выходные данные типа int.

Пример входных и выходных данных

input 		output

5 		
1 2 3 2 4	1 2 3 2 4
2 5 1		1 0 1
5		1 2 3 2 4 5
7		7 1 2 3 2 4 5
3 0		7 1 2 0 3 2 4 5
2		7 1 0 3 2 4 5


717-2_erb-3-2.c

Двусвязные списки:

Необходимо реализовать функции для работы с односвязным списком:
	// инициализация пустого списка
		void init(list* l);
	//удалить все элементы из списка
		void clear(list* l);
	// проверка на пустоту списка
		int isEmpty(list* l)
	// поиск элемента по значению. вернуть NULL если элемент не найден
		node* find(list* l, int value);
	// вставка значения в конец списка, вернуть 0 если успешно
		int push_back(list* l, int value);
	// вставка значения в начало списка, вернуть 0 если успешно
		int push_front(list* l, int value);
	// вставка значения после указанного узла, вернуть 0 если успешно
		int insertAfter(node* n, int value);
	// вставка значения перед указанным узлом, вернуть 0 если успешно
		int insertBefore(node* n, int value);
	// удалить первый элемент из списка с указанным значением, вернуть 0 если успешно
		int removeFirst(list* l, int value);
	// удалить последний элемент из списка с указанным значением, вернуть 0 если успешно
		int removeLast(list* l, int value);
	// вывести все значения из списка в прямом порядке, через пробел, после окончания вывода перейти на новую строку
		void print(list* l);
	// вывести все значения из списка в обратном порядке, через пробел, после окончания вывода перейти на новую строку
		void print_invers(list* l);



Используя реализованные функции реализовать программу которая:
	1. считать количество элементов n: n - натуральное число, не превышающее 2147483647;
	2. создать пустой список, считать n элементов a: a - целое число, не превышающее по модулю 2147483647, и занести их в список;
	3. вывести содержимое списка используя функцию print;
	4. считать k1 ,k2 ,k3: k1, k2, k3 - целые числа, не превышающее по модулю 2147483647, и вывести ‘1’ если в списке существует элемент с таким значением. ‘0’ если нет. Перейти на новую строку.
	5. считать m: m - целое число, не превышающее по модулю 2147483647, и вставить его в конец списка;
	6. вывести содержимое списка используя функцию print_invers;
	7. считать t: t - целое число, не превышающее по модулю 2147483647, и вставить его в начало списка;
	8. вывести содержимое списка используя функцию print;
	9. считать j: j - натуральное число, не превышающее 2147483647, и x: x - целое число, не превышающее по модулю 2147483647, и вставить значение x после j-ого элемента списка;
	10. вывести содержимое списка используя функцию print_invers;
	11. считать u: j - натуральное число, не превышающее 2147483647, и x: y - целое число, не превышающее по модулю 2147483647, и вставить значение y перед u-ым элемента списка;
	12. вывести содержимое списка используя функцию print;
	13. считать z: z - целое число, не превышающее по модулю 2147483647, и удалить первый элемент хранящий значение z из списка;
	14. вывести содержимое списка используя функцию print_invers;
	15. считать r: r - целое число, не превышающее по модулю 2147483647, и удалить последний элемент хранящий значение r из списка;
	16. вывести содержимое списка используя функцию print;
	17. очистить список.

Входные и выходные данные типа int.

Пример входных и выходных данных

input 		output

5 		
1 2 3 2 4 	1 2 3 2 4
2 5 1 		1 0 1
1 		1 4 2 3 2 1
7 		7 1 2 3 2 4 1
3 0 		1 4 2 3 0 2 1 7
5 8 		7 1 2 0 8 3 2 4 1
2 		1 4 2 3 8 0 1 7
1		7 1 0 8 3 2 4

717-2_erb-4-1.c

Бинарное дерево поиска

Необходимо реализовать структуры данных и функции для работы с бинарным деревом поиска:
	//структура для хранения узла дерева. Необходимо хранитьссылки на потомков, предка и некоторое значение (целое число)
		struct node;
	//структура для хранения дерева. хранит ссылку на корень дерева и количество элементов в дереве
		struct tree;
	// инициализация пустого дерева
		void init(tree* t);
	//удалить все элементы из дерева
		void clear(tree* t);
	//поиск элемента по значению. вернуть 0 если элемент найден и ссылку на найденнйы элемент в переменную n если n != NULL. в случае если элемент не найден вернуть 1.
		int find(tree* t, int value, node* n);
	//вставка значения в дерево. вернуть 0 если вставка выполнена успешна, 1 если элемент уже существует, 2 если не удалось выделить память для нового элемента
		int insert(tree* t, int value);
	//удалить элемент из дерева. вернуть 0 если элемент был удален и 1 если нет элемента с указанным значением
		int remove(tree* t, int value);
	//удалить минимальный элемент из поддерева, корнем которого является n. вернуть значение удаленного элемента
		int removeMin(node* n);
	//выполнить правое вращение поддерева, корнем которого является n. вернуть 0 при успещшно выполнение операции и 1 в случае если вращение невозможно
		int rotateRight(node *n);
	//выполнить левое вращение поддерева, корнем которого является n. вернуть 0 при успещшно выполнение операции и 1 в случае если вращение невозможно
		int rotateLeft(node *n);
	// вывести все значения из поддерева корнем которого является n по уровнем, начиная с корня. каждый уровень выводится на своей строке. элементы в строке разделяются пробелом. если на указанном месте нет элемента, заменить его значением '_'. Если дерево пусто вывести '-'
		void print(node* n);
	// вывести все значения дерева t, аналогично функции print
		void printTree(tree* t);

Используя реализованные функции реализовать программу которая:
	1. создать пустое дерево, считать 4 элементов a: a - целое число, не превышающее по модулю 2147483647, и занести их в дерево;
	2. вывести дерево используя функцию printTree;
	3. считать 3 элементов a: a - целое число, не превышающее по модулю 2147483647, и занести их в дерево;
	4. вывести дерево используя функцию printTree;
	5. считать m1: m1 - целое число, не превышающее по модулю 2147483647, и найти элемент с заданным значением в дереве. вывести через пробел значение предка и потомков найденного элемента. если элемент не найден, вывести "_", если нет значений предка или потомков вывести ’’ вместо таких значений.
	6. считать m2: m2 - целое число, не превышающее по модулю 2147483647, и найти элемент с заданнымзначением в дереве. вывести через пробел значение предкаи потомков найденного элемента. если элемент не найден, вывести ‘-’, если нет значений предка или потомков вывести ‘_’ вместо таких значений.
	7. считать m3: m3 - целое число, не превышающее по модулю 2147483647, и удалить из дерева элемент с заданным значением
	8. вывести деревео используя printTree
	9. выполнять левый поворот дерева относительно корня, пока это возможно.
	10. вывести дерево используя команду printTree
	11. выполнять правый поворот дерева относительно корня, пока это возможно.
	12. вывести дерево используя команду printTree
	13. вывести на экран количество элементов в дереве
	14. очистить дерево
	15. вывести дерево на экран используя printTree

Входные и выходные данные типа int.

Пример входных и выходных данных:

input 		output
2 1 3 2 	2
 		1 3

0 4 5		2
 		1 3
		0 _ _ 4
		_ _ _ _ _ _ _ 5

3 		2 _ 4

6 		-

2		3
		1 4
		0 _ _ 5

		5
		4 _
		3 _ _ _
		1 _ _ _ _ _ _ _
		0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

		0
		_ 1
		_ _ _ 3
		_ _ _ _ _ _ _ 4
		_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 5

		5

		-

717-2_erb-5-1.c

Обход дерева

Реализовать обход дерева в ширину:
	1. считать с входного потока 7 чисел и занести их в дерево.
	2. Вывести все значения вершин дерева через пробел в порядке их посещения.


Входные и выходные данные типа int.

Пример входных и выходных данных:
input 		output
5 3 7 2 4 6 8	5 3 7 2 4 6 8

717-2_erb-5-2.c

Обход дерева

Реализовать прямой обход дерева. Использование рекурсии недопускается!
:
	1. считать с входного потока 7 чисел и занести их в дерево.
	2. Вывести все значения вершин дерева через пробел в порядке их посещения.


Входные и выходные данные типа int.

Пример входных и выходных данных:
input 		output
5 3 7 2 4 6 8	5 3 2 4 7 6 8

717-2_erb-5-3.c

Обход дерева

Реализовать обратный обход дерева с использованием рекурсии:
	1. считать с входного потока 7 чисел и занести их в дерево.
	2. Вывести все значения вершин дерева через пробел в порядке их посещения.


Входные и выходные данные типа int.

Пример входных и выходных данных:
input 		output
5 3 7 2 4 6 8	2 4 3 6 8 7 5

717-2_erb-6-1.c

В первом задании данной практики необходимо реализовать функцию сортировки массива целых чисел вида:
	int sorting_function(int *arr, int arr_len);
После работы функции arr должен стать упорядочным по возростанию или убыванию. На ваше усмотрение. Функция может возвращать всегда 0, либо возвращать количество операций сравнения и перестановки которые были выполнены во время сортировки (второй вариант упрастит выполнение первой лабораторной работы)

Задания:
	Считать количество элементов n: n - натуральное число, не превышающее 2147483647.
	Считать n целочисленных элементов x: x не превышает по модулю 2147483647.
	Отсортировать полученный массив сортировкой расчёской.
	Вывести отсортированный массив на экран через пробел.

Входные и выходные данные типа int.

717-2_erb-6-2.c

Во втором задании данной практики необходимо реализовать функцию сортировки массива целых чисел вида:
	int sorting_function(int *arr, int arr_len);
После работы функции arr должен стать упорядочным по возростанию или убыванию. На ваше усмотрение. Функция может возвращать всегда 0, либо возвращать количество операций сравнения и перестановки которые были выполнены во время сортировки (второй вариант упрастит выполнение первой лабораторной работы)

Задания:
	Считать количество элементов n: n - натуральное число, не превышающее 2147483647.
	Считать n целочисленных элементов x: x не превышает по модулю 2147483647.
	Отсортировать полученный массив сортировкой Шелла.
	Вывести отсортированный массив на экран через пробел.

Входные и выходные данные типа int.

717-2_erb-7-1.c

Во втором задании данной практики необходимо реализовать функцию сортировки массива целых чисел вида:
	int sorting_function(int *arr, int arr_len);
После работы функции arr должен стать упорядочным по возростанию или убыванию. На ваше усмотрение. Функция может возвращать всегда 0, либо возвращать количество операций сравнения и перестановки которые были выполнены во время сортировки (второй вариант упрастит выполнение первой лабораторной работы)

Задания:
	Считать количество элементов n: n - натуральное число, не превышающее 2147483647.
	Считать n целочисленных элементов x: x не превышает по модулю 2147483647.
	Отсортировать полученный массив Быстрой сортировкой.
	Вывести отсортированный массив на экран через пробел. (после чего перейти на новую строку)

Входные и выходные данные типа int.

717-2_erb-7-2.c

Во втором задании данной практики необходимо реализовать функцию сортировки массива целых чисел вида:
	int sorting_function(int *arr, int arr_len);
После работы функции arr должен стать упорядочным по возростанию или убыванию. На ваше усмотрение. Функция может возвращать всегда 0, либо возвращать количество операций сравнения и перестановки которые были выполнены во время сортировки (второй вариант упрастит выполнение первой лабораторной работы)

Задания:
	Считать количество элементов n: n - натуральное число, не превышающее 2147483647.
	Считать n целочисленных элементов x: x не превышает по модулю 2147483647.
	Отсортировать полученный массив Пирамидальной сортировкой.
	Вывести отсортированный массив на экран через пробел. (после чего перейти на новую строку)

Входные и выходные данные типа int.
